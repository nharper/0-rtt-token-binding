<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Token Binding for 0-RTT TLS 1.3 Connections</title>

  
<style type="text/css">/*<![CDATA[*/
@viewport {
  zoom: 1.0;
  width: extend-to-zoom;
}
@-ms-viewport {
  width: extend-to-zoom;
  zoom: 1.0;
}

@media screen and (min-width: 1024px) {
  ul.toc, #rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    padding: 0 1em;
    z-index: 1;
  }
  #rfc\.toc {
    top: 16px;
  }
  ul.toc {
    top: 80px;
    overflow: auto;
  }

  body {
    padding-left: 1.5em;
    padding-right: 29em;
  }
}

body {
  font: 15px "Helvetica Neue",Helvetica,Arial,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 130%;
  margin: 2.5em auto;
  max-width: 724px;
}

.title, .filename, h1, h2, h3, h4 {
  font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size-adjust: 0.5;
  font-weight: 500;
  color: #333;
  line-height: 100%;
  margin: 0.8em 0 0.3em;
}
.title { font-size: 36px; }
h1 { font-size: 30px; }
h2 { font-size: 24px; }
h3, h4 { font-size: 18px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

ul.toc li {
  list-style: none;
  text-indent: -2.5em;
  padding-left: 2.5em;
  padding-bottom: 5px;
  margin: 0;
}
ul.toc ul {
  margin: 0;
}
/* xml2rfc nests ul directly inside ul which messes with the style badly */
ul.toc, ul.toc>ul, ul.toc ul>ul {
  margin: 0 0 0 1.5em;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header {
  width: 100%;
}
table.header td {
  border: none;
  background-color: transparent;
  color: black;
}
.filename {
  color: rgb(119, 119, 119);
  font-size: 23px;
  font-weight: normal;
  height: auto;
  line-height: 100%;
}
#rfc\.abstract+p {
  font-size: 20px;
  font-weight: 300;
  line-height: 130%;
}

samp, tt, code, pre {
  font: 11pt consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure {
  font-style: italic;
  margin: 0 1.5em;
}

address {
  margin: 10px 0 0;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn {
  font-weight: bold;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

ol, ul, li, p {
  padding: 0;
  margin: 0.5em 0 0.5em 2em;
}
li, p {
  margin-left: 0;
}
address {
  font-style: normal;
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>


  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Requirements Language"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Proposed Design"/>
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 TokenBinding Signature Definition"/>
<link href="#rfc.section.2.1.1" rel="Chapter" title="2.1.1 Selecting Which Exporter Secret to Use"/>
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Negotiating Token Binding"/>
<link href="#rfc.section.2.2.1" rel="Chapter" title="2.2.1 Token Binding Negotiation TLS Extension"/>
<link href="#rfc.section.2.2.2" rel="Chapter" title="2.2.2 Indicating Use of 0-RTT Token Binding"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Implementation Challenges"/>
<link href="#rfc.section.4" rel="Chapter" title="4 IANA Considerations"/>
<link href="#rfc.section.5" rel="Chapter" title="5 Security Considerations"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Proof of Possession of Token Binding Key"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Attacks on PSK-only Key Exchange and Token Binding"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Exporter Replayability"/>
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Replay Mitigations"/>
<link href="#rfc.section.5.4.1" rel="Chapter" title="5.4.1 Server Mitigations"/>
<link href="#rfc.section.5.4.2" rel="Chapter" title="5.4.2 Client Mitigations"/>
<link href="#rfc.section.5.5" rel="Chapter" title="5.5 Early Data Ticket Age Window"/>
<link href="#rfc.section.6" rel="Chapter" title="6 Acknowledgements"/>
<link href="#rfc.references" rel="Chapter" title="7 Normative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Harper, N." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-tokbind-tls13-0rtt" />
  <meta name="dct.issued" scheme="ISO8601" content="2017-6-26" />
  <meta name="dct.abstract" content="This document describes how Token Binding can be used in the 0-RTT data of a TLS 1.3 connection. This involves updating how Token Binding negotiation works and adding a mechanism for indicating whether a server prevents replay. A TokenBindingMessage sent in 0-RTT data has different security properties than one sent after the TLS handshake has finished, which this document also describes." />
  <meta name="description" content="This document describes how Token Binding can be used in the 0-RTT data of a TLS 1.3 connection. This involves updating how Token Binding negotiation works and adding a mechanism for indicating whether a server prevents replay. A TokenBindingMessage sent in 0-RTT data has different security properties than one sent after the TLS handshake has finished, which this document also describes." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">Token Binding Working Group</td>
  <td class="right">N. Harper</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">Google Inc.</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">June 26, 2017</td>
</tr>
<tr>
  <td class="left">Expires: December 28, 2017</td>
  <td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Token Binding for 0-RTT TLS 1.3 Connections<br />
  <span class="filename">draft-ietf-tokbind-tls13-0rtt</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document describes how Token Binding can be used in the 0-RTT data of a TLS 1.3 connection. This involves updating how Token Binding negotiation works and adding a mechanism for indicating whether a server prevents replay. A TokenBindingMessage sent in 0-RTT data has different security properties than one sent after the TLS handshake has finished, which this document also describes.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 28, 2017.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2017 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Requirements Language</a></li>
</ul><li>2.   <a href="#rfc.section.2">Proposed Design</a></li>
<ul><li>2.1.   <a href="#rfc.section.2.1">TokenBinding Signature Definition</a></li>
<ul><li>2.1.1.   <a href="#rfc.section.2.1.1">Selecting Which Exporter Secret to Use</a></li>
</ul><li>2.2.   <a href="#rfc.section.2.2">Negotiating Token Binding</a></li>
<ul><li>2.2.1.   <a href="#rfc.section.2.2.1">Token Binding Negotiation TLS Extension</a></li>
<li>2.2.2.   <a href="#rfc.section.2.2.2">Indicating Use of 0-RTT Token Binding</a></li>
</ul></ul><li>3.   <a href="#rfc.section.3">Implementation Challenges</a></li>
<li>4.   <a href="#rfc.section.4">IANA Considerations</a></li>
<li>5.   <a href="#rfc.section.5">Security Considerations</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Proof of Possession of Token Binding Key</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Attacks on PSK-only Key Exchange and Token Binding</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Exporter Replayability</a></li>
<li>5.4.   <a href="#rfc.section.5.4">Replay Mitigations</a></li>
<ul><li>5.4.1.   <a href="#rfc.section.5.4.1">Server Mitigations</a></li>
<li>5.4.2.   <a href="#rfc.section.5.4.2">Client Mitigations</a></li>
</ul><li>5.5.   <a href="#rfc.section.5.5">Early Data Ticket Age Window</a></li>
</ul><li>6.   <a href="#rfc.section.6">Acknowledgements</a></li>
<li>7.   <a href="#rfc.references">Normative References</a></li>
<li><a href="#rfc.authors">Author's Address</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">Token Binding (<a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>) cryptographically binds security tokens (e.g. HTTP cookies, OAuth tokens) to the TLS layer on which they are presented. It does so by signing an <a href="#RFC5705">[RFC5705]</a> exporter value from the TLS connection. TLS 1.3 introduces a new mode that allows a client to send application data on its first flight. If this 0-RTT data contains a security token, then a client using Token Binding would want to prove possession of its Token Binding private key so that the server can verify the binding. The <a href="#RFC5705">[RFC5705]</a>-style exporter provided by TLS 1.3 cannot be run until the handshake has finished. TLS 1.3 also provides an exporter that can be used with 0-RTT data, but it requires that the application explicitly specify that use.  This document specifies how to use the early_exporter_secret with Token Binding in TLS 1.3 0-RTT data.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#requirements-language" id="requirements-language">Requirements Language</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;,  &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in <a href="#RFC2119">[RFC2119]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#proposed-design" id="proposed-design">Proposed Design</a></h1>
<p id="rfc.section.2.p.1">A TokenBinding struct as defined in <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a> contains a signature of the EKM value from the TLS layer. Under normal circumstances, a TokenBinding on a TLS 1.3 connection would use the exporter_secret to derive the EKM value. When 0-RTT data is assembled to be sent, the exporter_secret is not yet available.  This design changes the definition of the TokenBinding.signature field to use the exporter with either early_exporter_secret or exporter_secret.  Since no negotiation for the connection can happen before the client sends this TokenBindingMessage in 0-RTT data, this document also describes how a client decides what TokenBindingMessage to send in 0-RTT data and how a server should interpret that message.</p>
<p id="rfc.section.2.p.2">If a client does not send any 0-RTT data, or if the server rejects the client&#8217;s 0-RTT data, then the client MUST use the 1-RTT exporter, as defined in <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>.</p>
<h1 id="rfc.section.2.1"><a href="#rfc.section.2.1">2.1.</a> <a href="#tokenbinding-signature-definition" id="tokenbinding-signature-definition">TokenBinding Signature Definition</a></h1>
<p id="rfc.section.2.1.p.1">In <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>, the signature field of the TokenBinding struct is defined to be the signature of a concatentation that includes the EKM value. Depending on the circumstances, the exporter value in section 7.3.3 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> is computed using either exporter_secret or early_exporter_secret as the Secret.</p>
<p id="rfc.section.2.1.p.2">When early_exporter_secret is used as the Secret, the client MUST indicate this use so the server knows which secret to use in signature verification. This indication is done through a new Token Binding extension, &#8220;early_exporter&#8221; (with extension type TBD). This extension always has 0-length data, so the full Extension struct is the bytes {0xTBD, 0x00, 0x00}. The early_exporter extension MUST be present in every TokenBinding struct where the exporter that is signed uses the early_exporter_secret, and it MUST NOT be present in any other TokenBinding structs.</p>
<h1 id="rfc.section.2.1.1"><a href="#rfc.section.2.1.1">2.1.1.</a> <a href="#selecting-which-exporter-secret-to-use" id="selecting-which-exporter-secret-to-use">Selecting Which Exporter Secret to Use</a></h1>
<p id="rfc.section.2.1.1.p.1">A client which is not sending any 0-RTT data on a connection MUST use the exporter defined in <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> (using exporter_secret as the Secret) for all TokenBindingMessages on that connection so that it is compatible with <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>.</p>
<p id="rfc.section.2.1.1.p.2">When a client sends a TokenBindingMessage in 0-RTT data, it must use the early_exporter_secret. If the server accepts the 0-RTT data, the client must continue to use the early_exporter_secret for the rest of the connection. If the server rejects 0-RTT data, the client must use the exporter_secret.</p>
<h1 id="rfc.section.2.2"><a href="#rfc.section.2.2">2.2.</a> <a href="#negotiating-token-binding" id="negotiating-token-binding">Negotiating Token Binding</a></h1>
<h1 id="rfc.section.2.2.1"><a href="#rfc.section.2.2.1">2.2.1.</a> <a href="#token-binding-negotiation-tls-extension" id="token-binding-negotiation-tls-extension">Token Binding Negotiation TLS Extension</a></h1>
<p id="rfc.section.2.2.1.p.1">In TLS 1.3, the &#8220;token_binding&#8221; extension is sent by a server in EncryptedExtensions, whereas in previous versions of TLS this extension was sent in the ServerHello message. On a 1-RTT connection (whether it be a new connection or resumption), no application data is sent in either direction before the &#8220;token_binding&#8221; TLS extension in the EncryptedExtensions, and the choice of Token Binding version and key parameter is up to the server based on what the client sent and what the server&#8217;s preferences are, following the same processing rules as in <a href="#I-D.ietf-tokbind-negotiation">[I-D.ietf-tokbind-negotiation]</a>.</p>
<p id="rfc.section.2.2.1.p.2">When a server issues a NewSessionTicket on a connection where Token Binding was negotiated, and the NewSessionTicket includes an &#8220;early_data&#8221; extension indicating that the ticket may be used to send 0-RTT data, the server may also include the &#8220;early_token_binding&#8221; extension in the NewSessionTicket to indicate that this ticket can be used for a future connection with Token Binding in 0-RTT data. If the server includes the &#8220;early_token_binding&#8221; extension in the NewSessionTicket, the server MUST store with the ticket the Token Binding version and key parameter used for the connection in which the ticket was issued. A client that supports Token Binding in 0-RTT data that receives a NewSessionTicket containing the &#8220;early_token_binding&#8221; extension must also store with the ticket the Token Binding version and key parameter of the connection in which the ticket was issued. The &#8220;early_token_binding&#8221; extension can appear in a NewSessionTicket message only if the &#8220;early_data&#8221; extension also appears in that message.</p>
<p id="rfc.section.2.2.1.p.3">A client that wishes to send a Token Binding message in 0-RTT data may only do so if the TLS connection in which the 0-RTT data is being sent is being resumed from a ticket which included the &#8220;early_token_binding&#8221; extension. Assuming the ticket included this extension, the client sends a ClientHello containing the &#8220;token_binding&#8221; extension, &#8220;early_data&#8221; extension, and &#8220;early_token_binding&#8221; extensions. The contents of the &#8220;token_binding&#8221; extension SHOULD be the same as they would be on a connection without &#8220;early_token_binding&#8221; to allow for the client and server to negotiate new Token Binding parameters if the early data is rejected. The Token Binding message sent in the 0-RTT data MUST be sent assuming that the same Token Binding version and key parameter from the connection where the ticket was received will also be negotiated on this connection. If the server includes the &#8220;early_data&#8221; extension in EncryptedExtensions in response to a ClientHello with &#8220;early_token_binding&#8221;, but the server does not include &#8220;early_token_binding&#8221; in EncryptedExtensions, or if the server&#8217;s &#8220;token_binding&#8221; extension does not match the values of the connection where the ticket was received, then the client MUST terminate the TLS connection with an illegal_parameter alert.</p>
<p id="rfc.section.2.2.1.p.4">If a server receives a ClientHello with the &#8220;early_token_binding&#8221; extension and supports Token Binding in 0-RTT data, it MUST perform the following checks:</p>
<p/>

<ul>
  <li>If either the &#8220;early_data&#8221; or &#8220;token_binding&#8221; extensions are missing from the ClientHello, terminate the TLS connection with an illegal_parameter alert.</li>
  <li>If the ticket used for resumption is missing either of the &#8220;early_data&#8221; or &#8220;early_token_binding&#8221; extensions, reject the early data.</li>
  <li>Process the &#8220;token_binding&#8221; extension as if it were received on a 1-RTT connection and compute the Token Binding version and key parameter to use. If either of these values do not match the values that were negotiated on the connection where the ticket used for resumption was sent, reject the early data.</li>
  <li>Perform any other checks to decide whether to accept early data. If the server chooses to accept early data, include in EncryptedExtensions the &#8220;early_data&#8221; extension, &#8220;early_token_binding&#8221; extension, and &#8220;token_binding&#8221; extension with the same version and key parameter from the previous connection.</li>
</ul>
<p id="rfc.section.2.2.1.p.6">A server that receives a ClientHello with &#8220;early_token_binding&#8221; cannot reject Token Binding and also accept early data at the same time. Said server may reject early data but still negotiate Token Binding.</p>
<p id="rfc.section.2.2.1.p.7">The behavior for the &#8220;token_binding&#8221; extension in 0-RTT is similar to that of ALPN and SNI: the client predicts the result of the negotiation, and if the actual negotiation differs, the server rejects the early data.</p>
<h1 id="rfc.section.2.2.2"><a href="#rfc.section.2.2.2">2.2.2.</a> <a href="#indicating-use-of-0-rtt-token-binding" id="indicating-use-of-0-rtt-token-binding">Indicating Use of 0-RTT Token Binding</a></h1>
<p id="rfc.section.2.2.2.p.1">The TLS extension &#8220;early_token_binding&#8221; (extension type TBD) is used in the TLS ClientHello and EncryptedExtensions to indicate use of 0-RTT Token Binding on the current connection. It is also used in a NewSessionTicket message to indicate that 0-RTT Token Binding may be used on a connection resumed with that ticket.  In all cases, the &#8220;extension_data&#8221; field of this extension is empty, so the entire encoding of this extension is 0xTBD 0xTBD 0x00 0x00.</p>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#implementation-challenges" id="implementation-challenges">Implementation Challenges</a></h1>
<p id="rfc.section.3.p.1">The client has to be able to modify the message it sends in 0-RTT data if the 0-RTT data gets rejected and needs to be retransmitted in 1-RTT data. Even if the Token Binding integration with 0-RTT were modified so that Token Binding never caused a 0-RTT reject that required rewriting a request, the client still has to handle the server rejecting the 0-RTT data for other reasons.</p>
<p id="rfc.section.3.p.2">HTTP2 allows for requests to different domains to share the same TLS connection if the SAN of the cert covers those domains. If one.example.com supports 0-RTT and Token Binding, but two.example.com only supports Token Binding as defined in <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>, those servers cannot share a cert and use HTTP2.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a></h1>
<p id="rfc.section.4.p.1">This document defines a new TLS extension &#8220;early_token_binding&#8221; with code point TBD which needs to be added to IANA&#8217;s TLS &#8220;ExtensionType Values&#8221; registry.</p>
<p id="rfc.section.4.p.2">This document defines a new Token Binding extension &#8220;early_exporter&#8221;, which needs to be added to the IANA &#8220;Token Binding Extensions&#8221; registry.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.5.p.1">Token Binding messages that use the 0-RTT exporter have weaker security properties than with the <a href="#RFC5705">[RFC5705]</a> exporter. If either party of a connection using Token Binding does not wish to use 0-RTT token bindings, they can do so: a client can choose to never send 0-RTT data on a connection where it uses token binding, and a server can choose to reject any 0-RTT data sent on a connection that negotiated token binding.</p>
<p id="rfc.section.5.p.2">0-RTT data in TLS 1.3 has weaker security properties than other kinds of TLS data. Specifically, TLS 1.3 does not guarantee non-replayability of data between connections. Token Binding has similar replayability issues when in 0-RTT data, but preventing replay of Token Binding and preventing replay of 0-RTT data are two separate problems. Token Binding is not designed to prevent replay of 0-RTT data, although solutions for preventing the replay of Token Binding might also be applicable to 0-RTT data.</p>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#proof-of-possession-of-token-binding-key" id="proof-of-possession-of-token-binding-key">Proof of Possession of Token Binding Key</a></h1>
<p id="rfc.section.5.1.p.1">When a Token Binding signature is generated using the exporter with early_exporter_secret, the value being signed is under the client&#8217;s control. An attacker with temporary access to the Token Binding private key can generate Token Binding signatures for as many future connections as it has NewSessionTickets for. An attacker can construct these to be usable at any time in the future up until the NewSessionTicket&#8217;s expiration. Section 4.6.1 of <a href="#I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</a> requires that a NewSessionTicket be valid for a maximum of 7 days.</p>
<p id="rfc.section.5.1.p.2">Unlike in <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a>, where the proof of possession of the Token Binding key proves that the client had possession at the time the TLS handshake finished, 0-RTT Token Binding only proves that the client had possession of the Token Binding key at some point after receiving the NewSessionTicket used for that connection.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#attacks-on-psk-only-key-exchange-and-token-binding" id="attacks-on-psk-only-key-exchange-and-token-binding">Attacks on PSK-only Key Exchange and Token Binding</a></h1>
<p id="rfc.section.5.2.p.1">An attacker who possesses the PSK can eavesdrop on an existing connection that uses that PSK to obtain a TokenBindingMessage that is valid on the connection and then hijack the connection to send whatever attacker-controlled data it wishes. Because the regular exporter closes over the server random, this TokenBindingMessage is valid only for that connection.</p>
<p id="rfc.section.5.2.p.2">If the attacker does the same thing with a pure-PSK connection and 0-RTT Token Binding, the attacker can replay the original ClientHello and the exporter will stay the same, allowing the attacker to obtain a TokenBindingMessage from one connection and replay it on future connections. The only way for a server to prevent this replay is to prevent the client from ever repeating a client random in the handshake.</p>
<p id="rfc.section.5.2.p.3">If a server accepting connections with PSK-only key establishment is concerned about the threat of PSK theft and also implements Token Binding, then that server must either reject all 0-RTT token bindings, or implement some form of preventing reuse of a client random.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#exporter-replayability" id="exporter-replayability">Exporter Replayability</a></h1>
<p id="rfc.section.5.3.p.1">The exporter specified in <a href="#I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</a> is chosen so that a client and server have the same exporter value only if they are on the same TLS connection. This prevents an attacker who can read the plaintext of a TokenBindingMessage sent on that connection from replaying that message on another connection (without also having the token binding private key). The 0-RTT exporter only covers the ClientHello and the PSK of the connection, so it does not provide this guarantee.</p>
<p id="rfc.section.5.3.p.2">An attacker with possession of the PSK secret and a transcript of the ClientHello and early data sent by a client under that PSK can extract the TokenBindingMessage, create a new connection to the server (using the same ClientHello and PSK), and send different application data with the same TokenBindingMessage. Note that the ClientHello contains public values for the (EC)DHE key agreement that is used as part of deriving the traffic keys for the TLS connection, so if the attacker does not also have the corresponding private values, they will not be able to read the server&#8217;s response or send a valid Finished message in the handshake for this TLS connection. Nevertheless, by that point the server has already processed the attacker&#8217;s message with the replayed TokenBindingMessage.</p>
<p id="rfc.section.5.3.p.3">This sort of replayability of a TokenBindingMessage is different than the replayability caveat of 0-RTT application data in TLS 1.3. A network observer can replay 0-RTT data from TLS 1.3 without knowing any secrets of the client or server, but the application data that is replayed is untouched. This replay is done by a more powerful attacker who is able to view the plaintext and then spoof a connection with the same parameters so that the replayed TokenBindingMessage still validates when sent with different application data.</p>
<h1 id="rfc.section.5.4"><a href="#rfc.section.5.4">5.4.</a> <a href="#replay-mitigations" id="replay-mitigations">Replay Mitigations</a></h1>
<p id="rfc.section.5.4.p.1">This section presents multiple ways that a client or server can mitigate the replay of a TokenBinding while still using Token Binding with 0-RTT data. Note that even with replay mitigations, 0-RTT Token Binding is vulnerable to other attacks.</p>
<h1 id="rfc.section.5.4.1"><a href="#rfc.section.5.4.1">5.4.1.</a> <a href="#server-mitigations" id="server-mitigations">Server Mitigations</a></h1>
<p id="rfc.section.5.4.1.p.1">If a server uses a session cache instead of stateless tickets, it can enforce that a PSK generated for resumption can only be used once. If an attacker tries to replay 0-RTT data (with a TokenBindingMessage), the server will reject it because the PSK was already used.</p>
<p id="rfc.section.5.4.1.p.2">Preventing all replay of 0-RTT data is not necessary to prevent replay of a TokenBinding. A server could implement a mechanism to prevent a particular TokenBinding from being presented on more than one connection.  In cases where a server&#8217;s TLS termination and application layer processing happen in different locations, this option might be easier to implement, especially when not all requests have bound tokens. This processing can also take advantage of the structure of the bound token, e.g. a token that identifies which user is making a request could shard its store of which TokenBindings have been seen based on the user ID.</p>
<p id="rfc.section.5.4.1.p.3">A server can prevent some, but not all, 0-RTT data replay with a tight time window for the ticket age that it will accept. See <a href="#ticket-age">Section 5.5</a> for more details.</p>
<h1 id="rfc.section.5.4.2"><a href="#rfc.section.5.4.2">5.4.2.</a> <a href="#client-mitigations" id="client-mitigations">Client Mitigations</a></h1>
<p id="rfc.section.5.4.2.p.1">A client cannot prevent a sufficiently motivated attacker from replaying a TokenBinding, but it can make it so difficult to replay the TokenBinding that it is easier for the attacker to steal the Token Binding key directly. If the client secures the resumption secret with the same level of protection as the Token Binding key, then the client has made it not worth the effort of the attacker to attempt to replay a TokenBinding.  Ideally the resumption secret (and Token Binding key) are protected strongly and virtually non-exportable.</p>
<h1 id="rfc.section.5.5"><a href="#rfc.section.5.5">5.5.</a> <a href="#ticket-age" id="ticket-age">Early Data Ticket Age Window</a></h1>
<p id="rfc.section.5.5.p.1">When an attacker with control of the PSK secret replays a TokenBindingMessage, it has to use the same ClientHello that the client used. The ClientHello includes an &#8220;obfuscated_ticket_age&#8221; in its EarlyDataIndication extension, which the server can use to narrow the window in which that ClientHello will be accepted. Even if a PSK is valid for a week, the server will only accept that particular ClientHello for a smaller time window based on the ticket age. A server should make their acceptance window for this value as small as practical to limit an attacker&#8217;s ability to replay a ClientHello and send new application data with the stolen TokenBindingMessage.</p>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#acknowledgements" id="acknowledgements">Acknowledgements</a></h1>
<p id="rfc.section.6.p.1">The author would like to thank David Benjamin, Steven Valdez, Bill Cox, and Andrei Popov for their feedback and suggestions.</p>
<h1 id="rfc.references"><a href="#rfc.references">7.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tls-tls13">[I-D.ietf-tls-tls13]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tls-tls13-20">The Transport Layer Security (TLS) Protocol Version 1.3</a>", Internet-Draft draft-ietf-tls-tls13-20, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tokbind-negotiation">[I-D.ietf-tokbind-negotiation]</b>
      </td>
      <td class="top"><a>Popov, A.</a>, <a>Nystrom, M.</a>, <a>Balfanz, D.</a> and <a>A. Langley</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tokbind-negotiation-08">Transport Layer Security (TLS) Extension for Token Binding Protocol Negotiation</a>", Internet-Draft draft-ietf-tokbind-negotiation-08, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="I-D.ietf-tokbind-protocol">[I-D.ietf-tokbind-protocol]</b>
      </td>
      <td class="top"><a>Popov, A.</a>, <a>Nystrom, M.</a>, <a>Balfanz, D.</a>, <a>Langley, A.</a> and <a>J. Hodges</a>, "<a href="http://tools.ietf.org/html/draft-ietf-tokbind-protocol-14">The Token Binding Protocol Version 1.0</a>", Internet-Draft draft-ietf-tokbind-protocol-14, April 2017.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5705">[RFC5705]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc5705">Keying Material Exporters for Transport Layer Security (TLS)</a>", RFC 5705, DOI 10.17487/RFC5705, March 2010.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Author's Address</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Nick Harper</span> 
	  <span class="n hidden">
		<span class="family-name">Harper</span>
	  </span>
	</span>
	<span class="org vcardline">Google Inc.</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:nharper@google.com">nharper@google.com</a></span>

  </address>
</div>

</body>
</html>
